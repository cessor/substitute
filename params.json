{"name":"Substitute","tagline":"A friendly substitute for python mocking frameworks.","body":"Substitute\r\n==========\r\n\r\nA friendly substitute for python mocking frameworks [*](http://nsubstitute.github.io/).\r\nIt helps you replace the dependent-on components of a class when you are writing unit tests. It provides what others call Mocks or Stubs. It is loosely based on [NSubstitute](http://nsubstitute.github.io/), my favorite substitution framework for .NET.\r\n\r\n## Creating a substitute...\r\nTo use a substitute in your tests simply create it like this:\r\n\r\n    person = Substitute()\r\n\r\n# Providing data...\r\nIn order to pass indirect input into the system under test you can either specify some properties or define the data that will be returned when a method is called.\r\n\r\n## ...from properties\r\n### Provide data as properties\r\n\r\n    person = Substitute()\r\n    person.name = 'Johannes'\r\n\r\n### Or behave like a dictionary\r\n    person['name'] = 'Johannes'\r\n\r\n## ...from methods\r\n### Always return the same value and ignore all parameters\r\n    # Configuration\r\n    calculator = Substitute()\r\n    calculator.add.returns(3)\r\n\r\n    # Actual call\r\n    calculator.add()    # returns 3\r\n    calculator.add('a') # returns 3\r\n    calculator.add(1,2) # returns 3\r\n\r\n### Only return data for specific parameters\r\n    calculator.add(1,2).returns(3)\r\n\r\n    calculator.add(1,2) # returns 3\r\n    calculator.add(4,5) # returns None\r\n\r\n### Only return data for parameters of the correct signature\r\n    calculator.add(int, int).returns(9)\r\n    \r\n    calculator.add(4, 5)    # returns 9\r\n    calculator.add('a','b') # returns None\r\n    \r\n### Raising Exceptions\r\n    # Configuration\r\n    calculator.divide.raises(DivisionByZeroError)\r\n\r\n    # Actual call\r\n    calculator.divide(10, 0) # raises error\r\n\r\n# Verifying that something has happened...\r\nYour system under test probably interacts with its surroundings by calling methods on other objects, some of which don't return anything. An example, as shown below would be calling the 'insert' or 'update' method on a database, or a log method. The calls a system makes can be checked on the substitute, too, and you can also verify that the call was made with the correct values.\r\n\r\n    # Configuration\r\n    address = City('London')              # some data\r\n    peter = Person(name='Peter', address) # \r\n    address = City('Berlin')              #\r\n    jane = Person(name='Jane', address)   # \r\n    \r\n    database = Substitute()         # Substituting the dependent-on component\r\n    \r\n    people = People(database)       # System under Test\r\n    expect_that = assert_true       # Readability is all!\r\n    \r\n## Checking that a call was made\r\n    people.move(peter, City('New York')) # Method under Test\r\n\r\n    expect_that(database.insert.was_called)\r\n\r\n## Checking that a call was not made\r\n    people.move(peter, City('New York')) # He already lives there\r\n\r\n    expect_that(database.update.was_not_called)\r\n\r\n## Checking that the call received proper values\r\n    people.move(peter, City('New York')) # Method under Test\r\n\r\n    # Fails, was called with New York!\r\n    expect_that(database.insert.was_called_with(City('London'))) \r\n\r\n    # Other examples\r\n    database.insert.was_called_with(City('New York')) # Succeeds!\r\n    database.insert.was_called_with_any(City)         # Check Type\r\n    database.insert.received(City('New York'))        # Also works\r\n    database.insert.received_any(City)                # You guessed it...\r\n\r\n## Checking on how many times something was called...\r\n    \r\n    people.marry(peter, jane)\r\n\r\n    expect_that(database.update.was_called_exactly(TWICE))\r\n\r\n    # Other examples \r\n    database.insert.was_called_exactly(ONCE)\r\n    database.insert.was_called_exactly(TWICE)\r\n    task.queue.was_called_exactly(times=10)\r\n\r\n\r\n# About mocks and stubs...\r\nDuring its lifetime an object will pass values to other components and receive values from them. In your test you want to control these indirect inputs and outputs. Indirect inputs are essentially data that are provided by a component. Indirect outputs (from the system under test) are essentially data that the dependent-on components receive from the system under test. Don't get confused, just always see it from the perspective of the thing being tested. Inputs come in, outputs go out. \r\nA component that provides canned data as indirect input is often referred to as a 'stub'. Configuring a substitute to provide canned data is especially useful when dealing with 'expensive' resources such as a database or the web. If, for example, you have a web client that parses the data from a website, you might want to provide some fake data to work with, rather than doing real requests to the web. Consider the following example:\r\n\r\n    class TrelloClient(object):\r\n        def __init__(self, requests):\r\n            self._web = requests\r\n        def all_boards(self):\r\n            response = self._web.get(trello_url).content\r\n            for board in parse(response):\r\n                yield Board.from_document(board)\r\n    ...\r\n\r\nHere, the (really great) requests module is used to make web requests. Unfortunately, the roundtrip might take a while (overall resulting in very long running tests) and also you don't want your tests to break when there is no internet, for example when you are running them at an airport a hotel right before you are supposed to give a talk at a conference and the wifi goes down all the time. You can easily reduce the impact of the dependency on the web in your test using a substitute:\r\n\r\n    def test_finding_all_boards():\r\n        '''Finds all boards'''\r\n        \r\n        # Arrange\r\n        response = Substitute()\r\n        response.content = \"{\"json\": \"<...data...>\"}\"\r\n        web = Substitute()\r\n        web.get.returns(response)\r\n\r\n        # System under Test\r\n        client = TrelloClient(web)\r\n\r\n        # Act\r\n        boards = client.all_boards()\r\n\r\n        # Assert length, content, whatever\r\n        assert_sequence(boards, ...) \r\n\r\n## Don't cross the streams...\r\nYou should avoid passing data to a system under test and then also verifying that call was made, like this:\r\n\r\n    def test_something():       \r\n        calculator = Substitute()\r\n        calculator.cos(0.5).returns(0.8776)\r\n        robot = Robot(calculator)\r\n        robot.rotate_arm()\r\n        expect_that(calculator.cos.received(0.5))\r\n\r\nThis test has many problems, one of which being that it doesn't test anything. It tests that the configured call is being made, which it is, when it was configured. Tests like this tend to be very brittle, they mirror the exact implementation. As soon as minor changes occur, they break. Tests should help you detect bad inputs and outputs and tell you when something changes unexpectedly, but they should allow a certain amount of change until they actually break. If they break too often, refactoring code will become very annoying because you can't make any changes at all. Testing is not about mirroring your code in another file, but to provide a safety net. Also they are good to isolate cases of potentially bad values. In a test as shown the system depends on the call being made. If it is made properly, the appropriate return value is given to the sut and the whole thing will run smoothely. There is no need to actually assert that the call is being made. If the configured return value is not obtained, the system will break anyway. If it doesn't - then why are you configuring the substitute to provide values? Try being as specific as necessary and as generic as possible. \r\n\r\n# Mocks aren't stubs...\r\nDon't believe me? Then read Martin Fowlers great article about the difference: [Mocks Aren't Stubs](http://martinfowler.com/articles/mocksArentStubs.html).\r\nSometimes a system under test calls methods on other components, without actually caring for a return value. This is often the case for functions that provide sideeffects, such as logging, writing to a file or saving an object to or updating one in a database. \r\nChecking on these interactions is often referred to as 'verifying expectations on a mock', but I never found the term 'mock' very helpful, therefore I try to avoid it where I can. It is all about verifying the indirect inputs and outputs of a system. Depending on who you ask, people will start confusing you anyway. Some say mock but mean a stub, some say mock but mean a test spy. These are all different things and I encourage you to look up the difference in this book: [http://xunitpatterns.com/](http://xunitpatterns.com/) but I try to avoid these terms whenever I can and recommend you do the same. Something goes in, something comes out. Don't call it mock or stub. It doesn't really matter and tests become way more readable when you leave out these weasel words. The basic python mocking tool is actually quite nice, but I don't like the notion of Mock or Magic Mock in it. Yet these are better than what other people have to deal with:\r\n\r\n    var stubUserRepository = MockRepository.GenerateStub<IUserRepository>();\r\n    var stubbedSmsSender = MockRepository.GenerateStub<ISmsSender>();\r\n    var theUser = new User{HashedPassword = \"this is not hashed password\"};    \r\n    stubUserRepository.Stub(x => x.GetUserByName(\"ayende\")).Return(theUser);\r\n\r\nYeah. I know*.\r\n\r\n<small>*) I really respect ayende and have been using the incredible RhinoMocks for ages, but the it has a very steep learning curve. Just like the guys behind NSubstitute I just wanted a different syntax.</small>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}